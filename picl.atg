#include "symbolTable.h"

COMPILER picl
	/*PICL Language Compiler*/

	int // operators
		oPlus, oMinus, oMul;
	
	int // types
		tInt, tSet, tBool;
	
	int // object kinds
		var, proc;
	SymbolTable* tab;

	struct Const{
		int type;
		wchar_t* val;
	};
	
	void putError(wchar_t* errMsg){
		errors->Error(la->line, la->col, errMsg);
	}

	void initVars(){
		oPlus = 0;
		oMinus = 1;
		oMul = 2;
		tBool = 0;
		tInt = 1;
		tSet = 2;
		var = 0;
		proc = 1;
	}

CHARACTERS
  	letter 	 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  	digit 	 = "0123456789".
	hexDigit = "0123456789ABCDEF".
	cr	 = '\r'.
	lf	 = '\n'.
	tab	 = '\t'.

TOKENS
	ident	 = letter {letter | digit}.
	int	 = digit {digit}.
	set	 = "$" hexDigit hexDigit.
	Tint	 = "INT".
	Tset	 = "SET".
	Tbool	 = "BOOL".
	inc	 = "INC".
	dec	 = "DEC".
	rol	 = "ROL".
	ror	 = "ROR".
	if	 = "IF".
	then	 = "THEN".
	end	 = "END".
	elsif	 = "ELSIF".
	else	 = "ELSE".
	while	 = "WHILE".
	do	 = "DO".
	repeat	 = "REPEAT".
	until	 = "UNTIL".
	procedure= "PROCEDURE".
	begin	 = "BEGIN".
	return	 = "RETURN".
	module	 = "MODULE".
	const	 = "CONST".
	asg	 = ":=".
	eq	 = "=".
	ne	 = "#".
	gt	 = ">".
	lt	 = "<".
	ge	 = ">=".
	le	 = "<=".
	plus	 = "+".
	mins	 = "-".
	mul	 = "*".
	ti	 = "~".

COMMENTS FROM "{" TO "}" NESTED
COMMENTS FROM "(*" TO "*)" NESTED

IGNORE cr + lf + tab

PRODUCTIONS
/*------------------------------------------------------*/	
	Identificator<wchar_t* &name> = ident 	(. name = coco_string_create(t->val); .).
	Integer = int.
	Set = set.
/*------------------------------------------------------*/	
	Constant<Const*& c>			(. c = new Const(); .)
	=
	Integer					(. c->val = t->val;
						   c->type = tInt; .)
	| Set					(. c->val = t->val;
						   c->type = tSet; .)
	.
/*------------------------------------------------------*/	
	Type<int &type> 
	= 
	Tint 					(. type = tInt; .)
	| Tset 					(. type = tSet; .)
	| Tbool					(. type = tBool; .).
/*------------------------------------------------------*/	
	VariableDeclaration 			(. wchar_t* name; int type; .)
	= 
	Type<type>
	Identificator<name>	 		(. tab->newObj(t->line, t->col, name, var, type); .)
	{"," Identificator<name>		(. tab->newObj(t->line, t->col, name, var, type); .)
	}.

/*------------------------------------------------------*/	
	Operator<int &op>
	= 
	plus 					(. op = oPlus; .)
	| mins 					(. op = oMinus; .)
	| mul					(. op = oMul; .).
/*------------------------------------------------------*/	
	Expression1Const<int &type> 		(. Const* c; int op; wchar_t* name; Object* obj;
						   wchar_t emsg[40];
						   coco_swprintf(emsg, 40, L"incompatibility of types");.)
	=
	Constant<c>				(. type = c->type; .)
	[Operator<op> 
	(Identificator<name> 			(. obj = tab->findObj(t->line, t->col, name);
						   if(type != obj->type)
						   	putError(emsg); .)
	| Constant<c>				(. if(type != c->type)
	                                                putError(emsg); .)
	)].
/*------------------------------------------------------*/	
	Expression<int &type> 			(. Const* c; int op, type2; wchar_t* name; Object* obj;
						   wchar_t emsg[40];
						   coco_swprintf(emsg, 40, L"incompatibility of types");.)
	= 
	Expression1Const<type> 
	| Identificator<name>			(. obj = tab->findObj(t->line, t->col, name);
						   type = obj->type; .) 
	([Operator<op> 
	(Identificator<name>			(. obj = tab->findObj(t->line, t->col, name);
						   if(type != obj->type)
							putError(emsg); .)
	| Constant<c>				(. if(type != c->type)
							putError(emsg); .)
	)] | Call<type>				
	).
/*------------------------------------------------------*/	
	Relation 
	= 
	eq
	| ne
	| lt
	| gt
	| le
	| ge
	.
/*------------------------------------------------------*/	
	Index = Integer.
/*------------------------------------------------------*/	
	Term 					(. Const* c; wchar_t* name; .)
	= 
	Identificator<name> 
	Relation 
	(Identificator<name>
	| Constant<c>
	) | [ti] 
	Identificator<name>
	["." Index
	].
/*------------------------------------------------------*/	
	Conjunction = Term {"&" Term}.
/*------------------------------------------------------*/	
	Disjunction = Term {"OR" Term}.
/*------------------------------------------------------*/	
	Condition = Conjunction | Disjunction.
/*------------------------------------------------------*/	
	Assignment<int &type> 
	= 
	asg Expression<type>
	.
/*------------------------------------------------------*/	
	Call<int &type> 
	= 
	"(" [Expression<type>
	] ")".
/*------------------------------------------------------*/	
	Command 				(. wchar_t* name; .)
	= 
	"!" [ti
	] Identificator<name>
	["." Index] | 
	(inc 
	| dec 
	| rol 
	| ror
	) Identificator<name>
	.
/*------------------------------------------------------*/	
	Query 					(. wchar_t* name; .)
	= 
	"?" [ti
	] Identificator<name>
	["." Index].
/*------------------------------------------------------*/	
	IfStat = if Condition then StatSeq {elsif Condition then StatSeq} [else StatSeq] end.
/*------------------------------------------------------*/	
	WhileStat = while Condition do StatSeq {elsif Condition do StatSeq} end.
/*------------------------------------------------------*/	
	RepeatStat = repeat StatSeq (until Condition | end).
/*------------------------------------------------------*/	
	Statement 				(. int type; wchar_t* name; .)
	=
	[Identificator<name>
	(Assignment<type>
	| Call<type>
	) | Command
	| Query
	| IfStat
	| WhileStat
	| RepeatStat
	].
/*------------------------------------------------------*/	
	StatSeq = Statement {";" Statement}.
/*------------------------------------------------------*/	
	FormalParameter 			(. int type; wchar_t* name; .)
	= 
	Type<type>
	Identificator<name>
	.
/*------------------------------------------------------*/	
	ProcedureHeading 			(. int type; wchar_t* name; .)
	= 
	procedure
	Identificator<name>
	["(" FormalParameter
	")"]
	[":"
	Type<type>
	].
/*------------------------------------------------------*/	
	ProcedureBody 				(. int type; wchar_t* name; .)
	= 
	[{VariableDeclaration
	} ";"]
	[begin
	StatSeq
	]
	[return Expression<type>
	] end Identificator<name>
	.
/*------------------------------------------------------*/	
	ProcedureDeclaration = ProcedureHeading ";" ProcedureBody.
/*------------------------------------------------------*/	
	Module 					(. Const* c; int type; wchar_t* name; .)
	= 
	module Identificator<name>
	";"
	[const {Identificator<name>
	"=" Constant<c>
	";"}] [Type<type>
	{Identificator<name>
	["," Identificator<name>
	] ";"}]
	{ProcedureDeclaration ";"} [begin StatSeq]
	end Identificator<name>
	".".
/*------------------------------------------------------*/	
	MainBody 
	=
	begin
	StatSeq
	end "."
	.
/*------------------------------------------------------*/	
	picl 					(. initVars(); .)
	= 
	Module 
	| "PROGRAM" 				(. tab->openScope(); .)
	{ProcedureDeclaration} 
	{VariableDeclaration}
	MainBody				(. tab->closeScope(); .)
	.
/*------------------------------------------------------*/	
END picl.
